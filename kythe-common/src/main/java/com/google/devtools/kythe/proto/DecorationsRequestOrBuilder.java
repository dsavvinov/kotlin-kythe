// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kythe/proto/xref.proto

package com.google.devtools.kythe.proto;

public interface DecorationsRequestOrBuilder extends
    // @@protoc_insertion_point(interface_extends:kythe.proto.DecorationsRequest)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The location of the file to fetch decorations for.  The ticket of location
   * must be non-empty.  It is an error in any case if location is invalid.
   * </pre>
   *
   * <code>.kythe.proto.Location location = 1;</code>
   */
  boolean hasLocation();
  /**
   * <pre>
   * The location of the file to fetch decorations for.  The ticket of location
   * must be non-empty.  It is an error in any case if location is invalid.
   * </pre>
   *
   * <code>.kythe.proto.Location location = 1;</code>
   */
  com.google.devtools.kythe.proto.Location getLocation();
  /**
   * <pre>
   * The location of the file to fetch decorations for.  The ticket of location
   * must be non-empty.  It is an error in any case if location is invalid.
   * </pre>
   *
   * <code>.kythe.proto.Location location = 1;</code>
   */
  com.google.devtools.kythe.proto.LocationOrBuilder getLocationOrBuilder();

  /**
   * <pre>
   * How to treat SPAN locations.
   * </pre>
   *
   * <code>.kythe.proto.DecorationsRequest.SpanKind span_kind = 10;</code>
   */
  int getSpanKindValue();
  /**
   * <pre>
   * How to treat SPAN locations.
   * </pre>
   *
   * <code>.kythe.proto.DecorationsRequest.SpanKind span_kind = 10;</code>
   */
  com.google.devtools.kythe.proto.DecorationsRequest.SpanKind getSpanKind();

  /**
   * <pre>
   * If dirty_buffer is non-empty, the results will be adjusted (patched) to
   * account for the regions of the specified file differing from the contents
   * of the dirty buffer.
   * </pre>
   *
   * <code>bytes dirty_buffer = 2;</code>
   */
  com.google.protobuf.ByteString getDirtyBuffer();

  /**
   * <pre>
   * If true, return the encoded source text for the selected window.  Source
   * text is not affected by patching.
   * </pre>
   *
   * <code>bool source_text = 3;</code>
   */
  boolean getSourceText();

  /**
   * <pre>
   * If true, return reference edges whose source nodes are located in the
   * selected window.  References are affected by patching.
   * </pre>
   *
   * <code>bool references = 4;</code>
   */
  boolean getReferences();

  /**
   * <pre>
   * If true, return definition locations, if possible, for each returned
   * reference target in the DecorationsReply.
   * </pre>
   *
   * <code>bool target_definitions = 6;</code>
   */
  boolean getTargetDefinitions();

  /**
   * <pre>
   * A collection of filter globs that specify which facts (by name) should be
   * returned for each node.  If filter is empty or unset, no node facts are
   * returned.  The filter applies to ALL referenced nodes.  See EdgesRequest
   * (graph.proto) for the format of the filter globs.
   * </pre>
   *
   * <code>repeated string filter = 5;</code>
   */
  java.util.List<java.lang.String>
      getFilterList();
  /**
   * <pre>
   * A collection of filter globs that specify which facts (by name) should be
   * returned for each node.  If filter is empty or unset, no node facts are
   * returned.  The filter applies to ALL referenced nodes.  See EdgesRequest
   * (graph.proto) for the format of the filter globs.
   * </pre>
   *
   * <code>repeated string filter = 5;</code>
   */
  int getFilterCount();
  /**
   * <pre>
   * A collection of filter globs that specify which facts (by name) should be
   * returned for each node.  If filter is empty or unset, no node facts are
   * returned.  The filter applies to ALL referenced nodes.  See EdgesRequest
   * (graph.proto) for the format of the filter globs.
   * </pre>
   *
   * <code>repeated string filter = 5;</code>
   */
  java.lang.String getFilter(int index);
  /**
   * <pre>
   * A collection of filter globs that specify which facts (by name) should be
   * returned for each node.  If filter is empty or unset, no node facts are
   * returned.  The filter applies to ALL referenced nodes.  See EdgesRequest
   * (graph.proto) for the format of the filter globs.
   * </pre>
   *
   * <code>repeated string filter = 5;</code>
   */
  com.google.protobuf.ByteString
      getFilterBytes(int index);

  /**
   * <pre>
   * If true, for every defines/binding Reference in the reply, a NodeInfo
   * will be provided for each node that Reference extends or overrides.
   * Furthermore, if definition_locations is true, the response's
   * definition_locations field will include (where possible) the locations of
   * the definitions of the nodes that are extended or overridden.
   * </pre>
   *
   * <code>bool extends_overrides = 7;</code>
   */
  boolean getExtendsOverrides();

  /**
   * <pre>
   * If true, return diagnostics for the given file.
   * </pre>
   *
   * <code>bool diagnostics = 8;</code>
   */
  boolean getDiagnostics();

  /**
   * <pre>
   * What kind of snippets to return (or none).
   * </pre>
   *
   * <code>.kythe.proto.SnippetsKind snippets = 9;</code>
   */
  int getSnippetsValue();
  /**
   * <pre>
   * What kind of snippets to return (or none).
   * </pre>
   *
   * <code>.kythe.proto.SnippetsKind snippets = 9;</code>
   */
  com.google.devtools.kythe.proto.SnippetsKind getSnippets();
}
